"use strict";
const PathType_1 = require("./Objects/osu!/PathType");
const PathApproximator_1 = require("./PathApproximator");
const Vector2_1 = require("./Objects/Vector2");
const Precision_1 = require("./Precision");
class SliderPath {
    constructor(pathType, controlPoints, expectedDistance) {
        this.isInitialised = false;
        this.pathApproximator = new PathApproximator_1.default();
        this.pathType = pathType;
        this.controlPoints = controlPoints;
        this.expectedDistance = expectedDistance;
        this.ensureInitialised();
    }
    ;
    ensureInitialised() {
        if (this.isInitialised)
            return;
        this.isInitialised = true;
        this.controlPoints = this.controlPoints !== null ? this.controlPoints : [];
        this.calculatedPath = [];
        this.cumulativeLength = [];
        this.calculatePath();
        this.calculateCumulativeLength();
    }
    ;
    calculatePath() {
        this.calculatedPath = [];
        let start = 0;
        let end = 0;
        for (let i = 0; i < this.controlPoints.length; i++) {
            end++;
            //Different class instances are always different, so check the x and y values for equality instead
            if (i === this.controlPoints.length - 1 || (this.controlPoints[i].x === this.controlPoints[i + 1].x && this.controlPoints[i].y === this.controlPoints[i + 1].y)) {
                let cpSpan = this.controlPoints.slice(start, end);
                this.calculateSubPath(cpSpan).forEach(t => {
                    if (this.calculatedPath.length === 0 || this.calculatedPath[this.calculatedPath.length - 1].x !== t.x || this.calculatedPath[this.calculatedPath.length - 1].y !== t.y) {
                        this.calculatedPath.push(new Vector2_1.Vector2(t.x, t.y));
                    }
                });
                start = end;
            }
        }
    }
    ;
    calculateSubPath(subControlPoints) {
        switch (this.pathType) {
            case PathType_1.PathType.Linear:
                return this.pathApproximator.approximateLinear(subControlPoints);
            case PathType_1.PathType.PerfectCurve:
                if (this.controlPoints.length !== 3 || subControlPoints.length !== 3)
                    break;
                const subPath = this.pathApproximator.approximateCircularArc(subControlPoints);
                if (subPath.length === 0)
                    break;
                return subPath;
            case PathType_1.PathType.Catmull:
                return this.pathApproximator.approximateCatmull(subControlPoints);
        }
        return this.pathApproximator.approximateBezier(subControlPoints);
    }
    ;
    calculateCumulativeLength() {
        let l = 0;
        this.cumulativeLength = [];
        this.cumulativeLength.push(l);
        for (let i = 0; i < this.calculatedPath.length - 1; i++) {
            let diff = this.calculatedPath[i + 1].subtract(this.calculatedPath[i]);
            let d = diff.length();
            if (this.expectedDistance !== null && this.expectedDistance !== undefined && this.expectedDistance - l < d) {
                this.calculatedPath[i + 1] = this.calculatedPath[i].add(diff.scale((this.expectedDistance - l) / d));
                this.calculatedPath.splice(i + 2, this.calculatedPath.length - 2 - i);
                l = this.expectedDistance;
                this.cumulativeLength.push(l);
                break;
            }
            l += d;
            this.cumulativeLength.push(l);
        }
        if (this.expectedDistance !== undefined && this.expectedDistance !== null && l < this.expectedDistance && this.calculatedPath.length > 1) {
            let diff = this.calculatedPath[this.calculatedPath.length - 1].subtract(this.calculatedPath[this.calculatedPath.length - 2]);
            let d = diff.length();
            if (d <= 0)
                return;
            this.calculatedPath[this.calculatedPath.length - 1].add(diff.scale((this.expectedDistance - l) / d));
            this.cumulativeLength[this.calculatedPath.length - 1] = this.expectedDistance;
        }
    }
    ;
    PositionAt(progress) {
        this.ensureInitialised();
        const d = this.progressToDistance(progress);
        return this.interpolateVertices(this.indexOfDistance(d), d);
    }
    ;
    progressToDistance(progress) {
        return Math.min(Math.max(progress, 0), 1) * this.expectedDistance;
    }
    ;
    interpolateVertices(i, d) {
        if (this.calculatedPath.length === 0)
            return new Vector2_1.Vector2(0, 0);
        if (i <= 0)
            return this.calculatedPath[0];
        if (i >= this.calculatedPath.length)
            return this.calculatedPath[this.calculatedPath.length - 1];
        const p0 = this.calculatedPath[i - 1];
        const p1 = this.calculatedPath[i];
        const d0 = this.cumulativeLength[i - 1];
        const d1 = this.cumulativeLength[i];
        if (Precision_1.Precision.almostEqualsNumber(d0, d1))
            return p0;
        const w = (d - d0) / (d1 - d0);
        let result = p0.add(p1.subtract(p0).scale(w));
        return result;
    }
    ;
    indexOfDistance(d) {
        let index = this.cumulativeLength.indexOf(d);
        if (index < 0) {
            for (let i = 0; i < this.cumulativeLength.length; i++) {
                if (this.cumulativeLength[i] > d) {
                    return i;
                }
            }
            return this.cumulativeLength.length;
        }
        return index;
    }
    ;
}
module.exports = SliderPath;
