"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Skill_1 = require("./Skill");
class Speed extends Skill_1.Skill {
    constructor() {
        super(...arguments);
        this.angle_bonus_begin = 5 * Math.PI / 6;
        this.pi_over_4 = Math.PI / 4;
        this.pi_over_2 = Math.PI / 2;
        this.SkillMultiplier = 1400;
        this.StrainDecayBase = 0.3;
        this.min_speed_bonus = 75;
        this.max_speed_bonus = 45;
        this.speed_balancing_factor = 40;
    }
    strainValueOf(currentObject) {
        const distance = Math.min(this.SINGLE_SPACING_THRESHOLD, currentObject.TravelDistance + currentObject.JumpDistance);
        const deltaTime = Math.max(this.max_speed_bonus, currentObject.DeltaTime);
        let speedBonus = 1.0;
        if (deltaTime < this.min_speed_bonus)
            speedBonus = 1 + Math.pow((this.min_speed_bonus - deltaTime) / this.speed_balancing_factor, 2);
        let angleBonus = 1.0;
        if (currentObject.Angle !== null && currentObject.Angle !== undefined && currentObject.Angle > 0 && currentObject.Angle < this.angle_bonus_begin) {
            angleBonus = 1 + Math.pow(Math.sin(1.5 * (this.angle_bonus_begin - currentObject.Angle)), 2) / 3.57;
            if (currentObject.Angle < this.pi_over_2) {
                angleBonus = 1.28;
                if (distance < 90 && currentObject.Angle < this.pi_over_4)
                    angleBonus += (1 - angleBonus) * Math.min((90 - distance) / 10, 1);
                else if (distance < 90)
                    angleBonus += (1 - angleBonus) * Math.min((90 - distance) / 10, 1) * Math.sin((this.pi_over_2 - currentObject.Angle) / this.pi_over_4);
            }
        }
        let returnValue = (1 + (speedBonus - 1) * 0.75) * angleBonus * (0.95 + speedBonus * Math.pow(distance / this.SINGLE_SPACING_THRESHOLD, 3.5)) / currentObject.StrainTime;
        return returnValue;
    }
    ;
}
exports.Speed = Speed;
;
