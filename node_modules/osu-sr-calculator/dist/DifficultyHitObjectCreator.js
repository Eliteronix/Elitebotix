"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const DifficultyHitObject_1 = require("./Objects/osu!/HitObjects/DifficultyHitObject");
const Slider_1 = require("./Objects/osu!/HitObjects/Slider");
const Spinner_1 = require("./Objects/osu!/HitObjects/Spinner");
class DifficultyHitObjectCreator {
    constructor() {
        this.normalized_radius = 52;
        this.TravelDistance = 0;
        this.JumpDistance = 0;
        this.Angle = 0;
        this.DeltaTime = 0;
        this.StrainTime = 0;
    }
    convertToDifficultyHitObjects(hitObjects, timeRate) {
        this.difficultyHitObjects = [];
        for (let i = 1; i < hitObjects.length; i++) {
            const lastLast = i > 1 ? hitObjects[i - 2] : null;
            const last = hitObjects[i - 1];
            const current = hitObjects[i];
            const difficultyHitObject = this.createDifficultyHitObject(lastLast, last, current, timeRate);
            this.difficultyHitObjects.push(difficultyHitObject);
        }
        return this.difficultyHitObjects;
    }
    ;
    createDifficultyHitObject(lastLast, last, current, timeRate) {
        this.lastLastObject = lastLast;
        this.lastObject = last;
        this.currentObject = current;
        this.timeRate = timeRate;
        this.setDistances();
        this.setTimingValues();
        return new DifficultyHitObject_1.DifficultyHitObject(this.currentObject, this.lastObject, this.lastLastObject, this.TravelDistance, this.JumpDistance, this.Angle, this.DeltaTime, this.StrainTime);
    }
    ;
    setDistances() {
        this.TravelDistance = 0;
        this.JumpDistance = 0;
        this.Angle = 0;
        this.DeltaTime = 0;
        this.StrainTime = 0;
        let scalingFactor = this.normalized_radius / this.currentObject.Radius;
        if (this.currentObject.Radius < 30) {
            var smallCircleBonus = Math.min(30 - this.currentObject.Radius, 5) / 50;
            scalingFactor *= 1 + smallCircleBonus;
        }
        if (this.lastObject instanceof Slider_1.Slider) {
            let lastSlider = this.lastObject;
            this.computeSliderCursorPosition(lastSlider);
            this.TravelDistance = lastSlider.LazyTravelDistance * scalingFactor;
        }
        const lastCursorPosition = this.getEndCursorPosition(this.lastObject);
        if (!(this.currentObject instanceof Spinner_1.Spinner))
            this.JumpDistance = this.currentObject.StackedPosition.scale(scalingFactor).subtract(lastCursorPosition.scale(scalingFactor)).length();
        if (this.lastLastObject !== null) {
            const lastLastCursorPosition = this.getEndCursorPosition(this.lastLastObject);
            const v1 = lastLastCursorPosition.subtract(this.lastObject.StackedPosition);
            const v2 = this.currentObject.StackedPosition.subtract(lastCursorPosition);
            const dot = v1.dot(v2);
            const det = v1.x * v2.y - v1.y * v2.x;
            this.Angle = Math.abs(Math.atan2(det, dot));
        }
    }
    ;
    setTimingValues() {
        this.DeltaTime = (this.currentObject.StartTime - this.lastObject.StartTime) / this.timeRate;
        this.StrainTime = Math.max(50, this.DeltaTime);
    }
    ;
    computeSliderCursorPosition(slider) {
        if (slider.LazyEndPosition !== null && slider.LazyEndPosition !== undefined)
            return;
        slider.LazyEndPosition = slider.StackedPosition;
        slider.LazyTravelDistance = 0;
        const approxFollowCircleRadius = slider.Radius * 3;
        function computeVertex(t) {
            let progress = (t - slider.StartTime) / slider.SpanDuration;
            if (progress % 2 >= 1)
                progress = 1 - progress % 1;
            else
                progress = progress % 1;
            let diff = slider.StackedPosition.add(slider.Path.PositionAt(progress)).subtract(slider.LazyEndPosition);
            let dist = diff.length();
            if (dist > approxFollowCircleRadius) {
                diff.normalize();
                dist -= approxFollowCircleRadius;
                slider.LazyEndPosition = slider.LazyEndPosition.add(diff.scale(dist));
                slider.LazyTravelDistance = slider.LazyTravelDistance === undefined ? dist : slider.LazyTravelDistance += dist;
            }
        }
        ;
        const scoringTimes = slider.NestedHitObjects.slice(1, slider.NestedHitObjects.length).map(t => { return t.StartTime; });
        scoringTimes.forEach(time => {
            computeVertex(time);
        });
    }
    ;
    getEndCursorPosition(object) {
        let pos = object.StackedPosition;
        if (object instanceof Slider_1.Slider) {
            this.computeSliderCursorPosition(object);
            pos = object.LazyEndPosition !== null && object.LazyEndPosition !== undefined ? object.LazyEndPosition : pos;
        }
        return pos;
    }
    ;
}
;
exports.default = DifficultyHitObjectCreator;
