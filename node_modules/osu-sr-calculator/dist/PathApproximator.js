"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vector2_1 = require("./Objects/Vector2");
const Precision_1 = require("./Precision");
class PathApproximator {
    constructor() {
        this.bezier_tolerance = 0.25;
        this.catmull_detail = 50;
        this.circular_arc_tolerance = 0.1;
    }
    approximateBezier(controlPoints) {
        let output = [];
        let count = controlPoints.length;
        if (count === 0)
            return output;
        let subdivisionBuffer1 = [];
        let subdivisionBuffer2 = [];
        for (let i = 0; i < count; i++) {
            subdivisionBuffer1.push(new Vector2_1.Vector2(0, 0));
        }
        for (let i = 0; i < count * 2 - 1; i++) {
            subdivisionBuffer2.push(new Vector2_1.Vector2(0, 0));
        }
        let toFlatten = [];
        let freeBuffers = [];
        const deepCopy = [];
        controlPoints.forEach(c => {
            deepCopy.push(new Vector2_1.Vector2(c.x, c.y));
        });
        toFlatten.push(deepCopy);
        let leftChild = subdivisionBuffer2;
        while (toFlatten.length > 0) {
            let parent = toFlatten.pop();
            if (this.bezierIsFlatEnough(parent)) {
                this.bezierApproximate(parent, output, subdivisionBuffer1, subdivisionBuffer2, count);
                freeBuffers.push(parent);
                continue;
            }
            let rightChild = [];
            if (freeBuffers.length > 0)
                rightChild = freeBuffers.pop();
            else {
                for (let i = 0; i < count; i++) {
                    rightChild.push(new Vector2_1.Vector2(0, 0));
                }
            }
            this.bezierSubdivide(parent, leftChild, rightChild, subdivisionBuffer1, count);
            for (let i = 0; i < count; i++) {
                parent[i] = leftChild[i];
            }
            toFlatten.push(rightChild);
            toFlatten.push(parent);
        }
        output.push(controlPoints[count - 1]);
        return output;
    }
    ;
    approximateCatmull(controlPoints) {
        let result = [];
        for (let i = 0; i < controlPoints.length - 1; i++) {
            const v1 = i > 0 ? controlPoints[i - 1] : controlPoints[i];
            const v2 = controlPoints[i];
            const v3 = i < controlPoints.length - 1 ? controlPoints[i + 1] : v2.add(v2).subtract(v1);
            const v4 = i < controlPoints.length - 2 ? controlPoints[i + 2] : v3.add(v3).subtract(v2);
            for (let c = 0; c < this.catmull_detail; c++) {
                result.push(this.catmullFindPoint(v1, v2, v3, v4, c / this.catmull_detail));
                result.push(this.catmullFindPoint(v1, v2, v3, v4, (c + 1) / this.catmull_detail));
            }
        }
        return result;
    }
    ;
    approximateCircularArc(controlPoints) {
        const a = controlPoints[0];
        const b = controlPoints[1];
        const c = controlPoints[2];
        const aSq = (b.subtract(c)).lengthSquared();
        const bSq = (a.subtract(c)).lengthSquared();
        const cSq = (a.subtract(b)).lengthSquared();
        if (Precision_1.Precision.almostEqualsNumber(aSq, 0) || Precision_1.Precision.almostEqualsNumber(bSq, 0) || Precision_1.Precision.almostEqualsNumber(cSq, 0))
            return [];
        const s = aSq * (bSq + cSq - aSq);
        const t = bSq * (aSq + cSq - bSq);
        const u = cSq * (aSq + bSq - cSq);
        const sum = s + t + u;
        if (Precision_1.Precision.almostEqualsNumber(sum, 0))
            return [];
        const centre = (a.scale(s).add(b.scale(t)).add(c.scale(u))).divide(sum);
        const dA = a.subtract(centre);
        const dC = c.subtract(centre);
        const r = dA.length();
        const thetaStart = Math.atan2(dA.y, dA.x);
        let thetaEnd = Math.atan2(dC.y, dC.x);
        while (thetaEnd < thetaStart) {
            thetaEnd += 2 * Math.PI;
        }
        let dir = 1;
        let thetaRange = thetaEnd - thetaStart;
        let orthoAtoC = c.subtract(a);
        orthoAtoC = new Vector2_1.Vector2(orthoAtoC.y, -orthoAtoC.x);
        if (orthoAtoC.dot(b.subtract(a)) < 0) {
            dir = -dir;
            thetaRange = 2 * Math.PI - thetaRange;
        }
        const amountPoints = 2 * r <= this.circular_arc_tolerance ? 2 : Math.max(2, Math.ceil(thetaRange / (2 * Math.acos(1 - this.circular_arc_tolerance / r))));
        let output = [];
        for (let i = 0; i < amountPoints; i++) {
            const fract = i / (amountPoints - 1);
            const theta = thetaStart + dir * fract * thetaRange;
            const o = new Vector2_1.Vector2(Math.cos(theta), Math.sin(theta)).scale(r);
            output.push(centre.add(o));
        }
        return output;
    }
    ;
    approximateLinear(controlPoints) {
        return controlPoints;
    }
    ;
    bezierIsFlatEnough(controlPoints) {
        for (let i = 1; i < controlPoints.length - 1; i++) {
            if ((controlPoints[i - 1].subtract(controlPoints[i].scale(2)).add(controlPoints[i + 1])).lengthSquared() > this.bezier_tolerance * this.bezier_tolerance * 4) {
                return false;
            }
        }
        return true;
    }
    ;
    bezierApproximate(controlPoints, output, subdivisionBuffer1, subdivisionBuffer2, count) {
        let l = subdivisionBuffer2;
        let r = subdivisionBuffer1;
        this.bezierSubdivide(controlPoints, l, r, subdivisionBuffer1, count);
        for (let i = 0; i < count - 1; i++) {
            l[count + i] = r[i + 1];
        }
        output.push(controlPoints[0]);
        for (let i = 1; i < count - 1; i++) {
            const index = 2 * i;
            const p = (l[index - 1].add(l[index].scale(2)).add(l[index + 1])).scale(0.25);
            output.push(p);
        }
    }
    ;
    bezierSubdivide(controlPoints, l, r, subdivisionBuffer, count) {
        let midpoints = subdivisionBuffer;
        for (let i = 0; i < count; i++) {
            midpoints[i] = controlPoints[i];
        }
        for (let i = 0; i < count; i++) {
            l[i] = midpoints[0];
            r[count - i - 1] = midpoints[count - i - 1];
            for (let j = 0; j < count - i - 1; j++) {
                midpoints[j] = (midpoints[j].add(midpoints[j + 1])).divide(2);
            }
        }
    }
    ;
    catmullFindPoint(vec1, vec2, vec3, vec4, t) {
        const t2 = t * t;
        const t3 = t * t2;
        let result = new Vector2_1.Vector2(0.5 * (2 * vec2.x + (-vec1.x + vec3.x) * t + (2 * vec1.x - 5 * vec2.x + 4 * vec3.x - vec4.x) * t2 + (-vec1.x + 3 * vec2.x - 3 * vec3.x + vec4.x) * t3), 0.5 * (2 * vec2.y + (-vec1.y + vec3.y) * t + (2 * vec1.y - 5 * vec2.y + 4 * vec3.y - vec4.y) * t2 + (-vec1.y + 3 * vec2.y - 3 * vec3.y + vec4.y) * t3));
        return result;
    }
    ;
}
;
exports.default = PathApproximator;
