"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const HitObject_1 = require("./HitObject");
const HeadCircle_1 = require("./SliderObjects/HeadCircle");
const TailCircle_1 = require("./SliderObjects/TailCircle");
const SliderTick_1 = require("./SliderObjects/SliderTick");
const RepeatPoint_1 = require("./SliderObjects/RepeatPoint");
/**
 * Class for sliders
 */
class Slider extends HitObject_1.HitObject {
    /**
     *
     * @param pos The raw position of the slider (as listed in the .osu file)
     * @param startTime The start time of the slider
     * @param path The calculated slider path of the slider
     * @param repeatCount The number of repeats this slider has
     * @param speedMultiplier The speed multiplier of this slider compared to the base bpm
     * @param beatLength The length of one beat in ms at this point in the map
     * @param mapDifficulty The difficulty settings of the beatmap
     * @param radius The radius of the slider head circle
     */
    constructor(pos, startTime, path, repeatCount, speedMultiplier, beatLength, mapDifficulty, radius) {
        super(pos, startTime, radius);
        this.LegacyLastTickOffset = 36;
        this.Path = path;
        this.EndPosition = this.Position.add(this.Path.PositionAt(1));
        this.calculateEndTimeAndTickDistance(speedMultiplier, beatLength, mapDifficulty, repeatCount, startTime, path.expectedDistance);
        this.Duration = this.EndTime - startTime;
        this.RepeatCount = repeatCount;
        this.createNestedHitObjects();
    }
    ;
    calculateEndTimeAndTickDistance(speedMultiplier, beatLength, mapDifficulty, repeatCount, startTime, expectedDistance) {
        const scoringDistance = 100 * mapDifficulty.SliderMultiplier * speedMultiplier;
        this.Velocity = scoringDistance / beatLength;
        this.SpanCount = repeatCount + 1;
        this.TickDistance = scoringDistance / mapDifficulty.SliderTickRate * 1;
        this.EndTime = startTime + this.SpanCount * expectedDistance / this.Velocity;
    }
    ;
    /**
     * Creates the nested hit objects (head and tail circle, slider ticks and repeat points) for this slider
     */
    createNestedHitObjects() {
        this.NestedHitObjects = [];
        this.createSliderEnds();
        this.createSliderTicks();
        this.createRepeatPoints();
        this.NestedHitObjects.sort((a, b) => {
            return a.StartTime - b.StartTime;
        });
        this.TailCircle.StartTime = Math.max(this.StartTime + this.Duration / 2, this.TailCircle.StartTime - this.LegacyLastTickOffset);
    }
    ;
    createSliderEnds() {
        this.HeadCircle = new HeadCircle_1.HeadCircle(this.Position, this.StartTime, this.Radius);
        this.TailCircle = new TailCircle_1.TailCircle(this.EndPosition, this.EndTime, this.Radius);
        this.NestedHitObjects.push(this.HeadCircle);
        this.NestedHitObjects.push(this.TailCircle);
    }
    ;
    createSliderTicks() {
        const max_length = 100000;
        const length = Math.min(max_length, this.Path.expectedDistance);
        const tickDistance = Math.min(Math.max(this.TickDistance, 0), length);
        if (tickDistance === 0)
            return;
        const minDistanceFromEnd = this.Velocity * 10;
        this.SpanDuration = this.Duration / this.SpanCount;
        for (let span = 0; span < this.SpanCount; span++) {
            const spanStartTime = this.StartTime + span * this.SpanDuration;
            const reversed = span % 2 === 1;
            for (let d = tickDistance; d <= length; d += tickDistance) {
                if (d > length - minDistanceFromEnd)
                    break;
                const distanceProgress = d / length;
                const timeProgress = reversed ? 1 - distanceProgress : distanceProgress;
                const sliderTickPosition = this.Position.add(this.Path.PositionAt(distanceProgress));
                const sliderTick = new SliderTick_1.SliderTick(sliderTickPosition, spanStartTime + timeProgress * this.SpanDuration, span, spanStartTime, this.Radius);
                this.NestedHitObjects.push(sliderTick);
            }
        }
    }
    ;
    createRepeatPoints() {
        for (let repeatIndex = 0, repeat = 1; repeatIndex < this.RepeatCount; repeatIndex++, repeat++) {
            const repeatPosition = this.Position.add(this.Path.PositionAt(repeat % 2));
            const repeatPoint = new RepeatPoint_1.RepeatPoint(repeatPosition, this.StartTime + repeat * this.SpanDuration, repeatIndex, this.SpanDuration, this.Radius);
            this.NestedHitObjects.push(repeatPoint);
        }
    }
    ;
}
exports.Slider = Slider;
;
