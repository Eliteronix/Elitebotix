"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const HitType_1 = require("./Objects/osu!/HitType");
const PathType_1 = require("./Objects/osu!/PathType");
const Vector2_1 = require("./Objects/Vector2");
const Beatmap_1 = require("./Objects/osu!/Beatmap");
const HitCircle_1 = require("./Objects/osu!/HitObjects/HitCircle");
const Slider_1 = require("./Objects/osu!/HitObjects/Slider");
const Spinner_1 = require("./Objects/osu!/HitObjects/Spinner");
const SliderPath = require("./SliderPath");
const Precision_1 = require("./Precision");
class BeatmapParser {
    parseBeatmap(data, mods) {
        if (!data)
            throw new Error('No beatmap found');
        this.beatmap = new Beatmap_1.Beatmap();
        let section = null;
        let lines = data.split('\n').map(line => line.trim());
        for (let line of lines) {
            if (line.startsWith('//'))
                continue;
            if (!line)
                continue;
            if (!section && line.includes('osu file format v')) {
                this.beatmap.Version = parseInt(line.split('osu file format v')[1], 10);
                continue;
            }
            if (/^\s*\[(.+?)\]\s*$/.test(line)) {
                section = /^\s*\[(.+?)\]\s*$/.exec(line)[1];
                continue;
            }
            switch (section) {
                case 'General': {
                    let [key, value] = line.split(':').map(v => v.trim());
                    if (key === 'StackLeniency')
                        this.beatmap.StackLeniency = parseFloat(value);
                    break;
                }
                case 'Difficulty': {
                    let [key, value] = line.split(':').map(v => v.trim());
                    this.beatmap[section][key] = parseFloat(value);
                    break;
                }
                case 'TimingPoints': {
                    let split = line.split(',');
                    const time = +split[0] + (this.beatmap.Version < 5 ? 24 : 0);
                    const beatLength = +split[1];
                    const speedMultiplier = beatLength < 0 ? 100 / -beatLength : 1;
                    let timeSignature = 4;
                    if (split.length >= 3)
                        timeSignature = split[2][0] === '0' ? 4 : +split[2];
                    let timingChange = true;
                    if (split.length >= 7)
                        timingChange = split[6][0] === '1';
                    if (timingChange) {
                        this.beatmap.TimingPoints.push({
                            Time: time,
                            BeatLength: beatLength,
                            TimeSignature: timeSignature
                        });
                    }
                    this.beatmap.DifficultyTimingPoints.push({
                        Time: time,
                        SpeedMultiplier: speedMultiplier
                    });
                    break;
                }
                case 'HitObjects': {
                    let split = line.split(',');
                    const pos = new Vector2_1.Vector2(+split[0], +split[1]);
                    const startTime = +split[2];
                    const hitType = +split[3];
                    let result = null;
                    const scale = (1 - 0.7 * (this.getCircleSize(mods) - 5) / 5) / 2;
                    const radius = 64 * scale;
                    if (hitType & HitType_1.HitType.Normal) {
                        result = this.createCircle(pos, startTime, radius);
                    }
                    if (hitType & HitType_1.HitType.Slider) {
                        let pathType;
                        let length = 0;
                        let pointSplit = split[5].split('|');
                        let points = [new Vector2_1.Vector2(0, 0)];
                        pointSplit.forEach(point => {
                            if (point.length === 1) {
                                switch (point) {
                                    case 'C':
                                        pathType = PathType_1.PathType.Catmull;
                                        break;
                                    case 'B':
                                        pathType = PathType_1.PathType.Bezier;
                                        break;
                                    case 'L':
                                        pathType = PathType_1.PathType.Linear;
                                        break;
                                    case 'P':
                                        pathType = PathType_1.PathType.PerfectCurve;
                                        break;
                                    default:
                                        pathType = PathType_1.PathType.Catmull;
                                        break;
                                }
                                return;
                            }
                            const temp = point.split(':');
                            points.push(new Vector2_1.Vector2(+temp[0], +temp[1]).subtract(pos));
                        });
                        function isLinear(p) { return Precision_1.Precision.almostEqualsNumber(0, (p[1].y - p[0].y) * (p[2].x - p[0].x) - (p[1].x - p[0].x) * (p[2].y - p[0].y)); }
                        if (points.length === 3 && pathType === PathType_1.PathType.PerfectCurve && isLinear(points))
                            pathType = PathType_1.PathType.Linear;
                        let repeatCount = +split[6];
                        repeatCount = Math.max(0, repeatCount - 1);
                        if (split.length > 7)
                            length = +split[7];
                        const slider = this.createSlider(pos, points, length, pathType, repeatCount, startTime, radius);
                        result = slider;
                    }
                    if (hitType & HitType_1.HitType.Spinner) {
                        const endTime = +split[5];
                        result = this.createSpinner(pos, startTime, endTime);
                    }
                    this.beatmap.HitObjects.push(result);
                }
            }
        }
        this.beatmap.HitObjects.forEach(h => {
            h.StackHeight = 0;
        });
        this.applyStacking(0, this.beatmap.HitObjects.length - 1);
        const scale = (1 - 0.7 * (this.getCircleSize(mods) - 5) / 5) / 2;
        this.beatmap.HitObjects.forEach(hitObject => {
            hitObject.calculateStackedPosition(scale);
        });
        return this.beatmap;
    }
    ;
    createCircle(pos, startTime, radius) {
        return new HitCircle_1.HitCircle(pos, startTime, radius);
    }
    ;
    createSlider(pos, points, length, pathType, repeatCount, startTime, radius) {
        const path = new SliderPath(pathType, points, Math.max(0, length));
        const speedMultiplier = this.getSpeedMultiplier(startTime);
        const beatLength = this.getBeatLength(startTime);
        return new Slider_1.Slider(pos, startTime, path, repeatCount, speedMultiplier, beatLength, this.beatmap.Difficulty, radius);
    }
    ;
    createSpinner(pos, startTime, endTime) {
        return new Spinner_1.Spinner(pos, startTime, endTime);
    }
    ;
    getSpeedMultiplier(startTime) {
        const currentTimingPoint = this.getTimingPoints(startTime, this.beatmap.DifficultyTimingPoints);
        return currentTimingPoint.SpeedMultiplier;
    }
    ;
    getBeatLength(startTime) {
        const currentTimingPoint = this.getTimingPoints(startTime, this.beatmap.TimingPoints);
        return currentTimingPoint.BeatLength;
    }
    ;
    getTimingPoints(startTime, timingPoints) {
        timingPoints.sort((a, b) => {
            return a.Time - b.Time;
        });
        let currentTimingPoint;
        for (let i = 0; i < timingPoints.length; i++) {
            if (timingPoints[i].Time > startTime) {
                currentTimingPoint = i - 1;
                break;
            }
        }
        if (currentTimingPoint < 0) {
            console.warn("Warning: first timing point after current hit object (", startTime, "). Defaulting to first timing point of the map");
            currentTimingPoint = 0;
        }
        if (currentTimingPoint === undefined)
            currentTimingPoint = timingPoints.length - 1;
        return timingPoints[currentTimingPoint];
    }
    ;
    applyStacking(startIndex, endIndex) {
        const stack_distance = 3;
        let TimePreempt = 600;
        if (this.beatmap.Difficulty.ApproachRate > 5)
            TimePreempt = 1200 + (450 - 1200) * (this.beatmap.Difficulty.ApproachRate - 5) / 5;
        else if (this.beatmap.Difficulty.ApproachRate < 5)
            TimePreempt = 1200 - (1200 - 1800) * (5 - this.beatmap.Difficulty.ApproachRate) / 5;
        else
            TimePreempt = 1200;
        let extendedEndIndex = endIndex;
        if (endIndex < this.beatmap.HitObjects.length - 1) {
            for (let i = endIndex; i >= startIndex; i--) {
                let stackBaseIndex = i;
                for (let n = stackBaseIndex + 1; n < this.beatmap.HitObjects.length; n++) {
                    const stackBaseObject = this.beatmap.HitObjects[stackBaseIndex];
                    if (stackBaseObject instanceof Spinner_1.Spinner)
                        break;
                    const objectN = this.beatmap.HitObjects[n];
                    if (objectN instanceof Spinner_1.Spinner)
                        continue;
                    const endTime = stackBaseObject instanceof HitCircle_1.HitCircle ? stackBaseObject.StartTime : stackBaseObject.EndTime;
                    const stackThresHold = TimePreempt * this.beatmap.StackLeniency;
                    if (objectN.StartTime - endTime > stackThresHold)
                        break;
                    const endPositionDistanceCheck = stackBaseObject instanceof Slider_1.Slider ? stackBaseObject.EndPosition.distance(objectN.Position) < stack_distance : false;
                    if (stackBaseObject.Position.distance(objectN.Position) < stack_distance || endPositionDistanceCheck) {
                        stackBaseIndex = n;
                        objectN.StackHeight = 0;
                    }
                }
                if (stackBaseIndex > extendedEndIndex) {
                    extendedEndIndex = stackBaseIndex;
                    if (extendedEndIndex === this.beatmap.HitObjects.length - 1)
                        break;
                }
            }
        }
        let extendedStartIndex = startIndex;
        for (let i = extendedEndIndex; i > startIndex; i--) {
            let n = i;
            let objectI = this.beatmap.HitObjects[i];
            if (objectI.StackHeight !== 0 || objectI instanceof Spinner_1.Spinner)
                continue;
            const stackThresHold = TimePreempt * this.beatmap.StackLeniency;
            if (objectI instanceof HitCircle_1.HitCircle) {
                while (--n >= 0) {
                    const objectN = this.beatmap.HitObjects[n];
                    if (objectN instanceof Spinner_1.Spinner)
                        continue;
                    const endTime = objectN instanceof HitCircle_1.HitCircle ? objectN.StartTime : objectN.EndTime;
                    if (objectI.StartTime - endTime > stackThresHold)
                        break;
                    if (n < extendedStartIndex) {
                        objectN.StackHeight = 0;
                        extendedStartIndex = n;
                    }
                    const endPositionDistanceCheck = objectN instanceof Slider_1.Slider ? objectN.EndPosition.distance(objectI.Position) < stack_distance : false;
                    if (endPositionDistanceCheck) {
                        const offset = objectI.StackHeight - objectN.StackHeight + 1;
                        for (let j = n + 1; j <= i; j++) {
                            const objectJ = this.beatmap.HitObjects[j];
                            if (objectN.EndPosition.distance(objectJ.Position) < stack_distance) {
                                objectJ.StackHeight -= offset;
                            }
                        }
                        break;
                    }
                    if (objectN.Position.distance(objectI.Position) < stack_distance) {
                        objectN.StackHeight = objectI.StackHeight + 1;
                        objectI = objectN;
                    }
                }
            }
            else if (objectI instanceof Slider_1.Slider) {
                while (--n >= startIndex) {
                    const objectN = this.beatmap.HitObjects[n];
                    if (objectN instanceof Spinner_1.Spinner)
                        continue;
                    if (objectI.StartTime - objectN.StartTime > stackThresHold)
                        break;
                    const objectNEndPosition = objectN instanceof HitCircle_1.HitCircle ? objectN.Position : objectN.EndPosition;
                    if (objectNEndPosition.distance(objectI.Position) < stack_distance) {
                        objectN.StackHeight = objectI.StackHeight + 1;
                        objectI = objectN;
                    }
                }
            }
        }
    }
    ;
    getCircleSize(mods) {
        if (mods.includes("HR"))
            return Math.min(this.beatmap.Difficulty.CircleSize * 1.3, 10);
        if (mods.includes("EZ"))
            return this.beatmap.Difficulty.CircleSize * 0.5;
        return this.beatmap.Difficulty.CircleSize;
    }
    ;
}
;
exports.default = BeatmapParser;
